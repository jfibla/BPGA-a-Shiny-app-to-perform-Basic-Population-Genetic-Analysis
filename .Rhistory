relocate(c(Pop_name, LAT, LON), .before = V1)
cordi <- select(admixture_data, c("POP1", "POP2", "LAT", "LON"))
Npop <- length(unique(admixture_data$POP2))
qpop <- matrix(NA, ncol = 2, nrow = Npop)
# Calculate mean ancestry proportions for each population
for (i in seq_len(Npop)) {
pop_subset <- admixture_data$POP2 == unique(admixture_data$POP2)[i]
qpop[i, ] <- apply(runs[pop_subset, ], 2, mean)
}
# Calculate mean coordinates for each population
coord_pop <- matrix(NA, ncol = 2, nrow = Npop) # Assuming LAT and LON as the two columns
for (i in seq_len(Npop)) {
pop_subset <- admixture_data$POP2 == unique(admixture_data$POP2)[i]
coord_pop[i, ] <- apply(cordi[pop_subset, c("LON", "LAT")], 2, mean)
}
library(mapplots)
library(maps)
# Expand x and y limits by 20%
xlim <- c(
min(coord_pop[,1]) - 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1])),
max(coord_pop[,1]) + 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1]))
)
ylim <- c(
min(coord_pop[,2]) - 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2])),
max(coord_pop[,2]) + 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2]))
)
# Create base map with adjusted limits
basemap(xlim, ylim)
pop_size
radius_scaling_factor
ylim
xlim
basemap(xlim, ylim)
coord_pop
runs <- fread(paste0("input_admx.2.Q"))
to_color <- fread("temporal/to_color.txt", header = FALSE)
colnames(to_color) <- c("POP1", "POP2")
coord <- fread(paste0("www/coord.txt"), header = TRUE)
# Combine population and ancestry data
admixture_data <- cbind(to_color, runs)
admixture_data <- merge(admixture_data, coord, by = c("POP1", "POP2"))
admixture_data <- admixture_data %>%
relocate(c(Pop_name, LAT, LON), .before = V1)
cordi <- select(admixture_data, c("POP1", "POP2", "LAT", "LON"))
Npop <- length(unique(admixture_data$POP2))
qpop <- matrix(NA, ncol = 2, nrow = Npop)
# Calculate mean ancestry proportions for each population
for (i in seq_len(Npop)) {
pop_subset <- admixture_data$POP2 == unique(admixture_data$POP2)[i]
qpop[i, ] <- apply(runs[pop_subset, ], 2, mean)
}
# Calculate mean coordinates for each population
coord_pop <- matrix(NA, ncol = 2, nrow = Npop) # Assuming LAT and LON as the two columns
for (i in seq_len(Npop)) {
pop_subset <- admixture_data$POP2 == unique(admixture_data$POP2)[i]
coord_pop[i, ] <- apply(cordi[pop_subset, c("LON", "LAT")], 2, mean)
}
library(mapplots)
library(maps)
# Expand x and y limits by 20%
xlim <- c(
min(coord_pop[,1]) - 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1])),
max(coord_pop[,1]) + 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1]))
)
ylim <- c(
min(coord_pop[,2]) - 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2])),
max(coord_pop[,2]) + 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2]))
)
# Create base map with adjusted limits
basemap(xlim, ylim)
par(mar = c(3, 3, 3, 3))  # Smaller margins
# Expand x and y limits by 20%
xlim <- c(
min(coord_pop[,1]) - 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1])),
max(coord_pop[,1]) + 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1]))
)
ylim <- c(
min(coord_pop[,2]) - 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2])),
max(coord_pop[,2]) + 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2]))
)
# Create base map with adjusted limits
basemap(xlim, ylim)
# Increase plot window size
dev.new(width = 10, height = 10)  # Adjust window size as needed
# Adjust margins
par(mar = c(3, 3, 3, 3))  # Smaller margins
# Expand x and y limits by 20%
xlim <- c(
min(coord_pop[,1]) - 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1])),
max(coord_pop[,1]) + 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1]))
)
ylim <- c(
min(coord_pop[,2]) - 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2])),
max(coord_pop[,2]) + 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2]))
)
# Create base map with adjusted limits
basemap(xlim, ylim)
plot(coord_pop, xlab = "LON", ylab = "LAT", type = "n", xlim = xlim, ylim = ylim)
map(add = TRUE, col = "grey90", fill = TRUE)
# Example population sizes for dynamic pie chart radius
lon_range <- max(coord_pop[, 1]) - min(coord_pop[, 1])  # Longitude range
lat_range <- max(coord_pop[, 2]) - min(coord_pop[, 2])  # Latitude range
plot_area <- lon_range * lat_range
radius_scaling_factor <- sqrt(plot_area) / 60  # Adjust the divisor based on desired size
pop_size <- runif(Npop, min = 1, max = 5)  # Random example
for (i in 1:Npop) {
scaled_radius <- pop_size[i] * radius_scaling_factor
add.pie(z = qpop[i,], x = coord_pop[i, 1], y = coord_pop[i, 2], labels = "",
radius = scaled_radius, col = rainbow(2))
}
# Add pie charts to the map
for (i in 1:Npop) {
add.pie(z = qpop[i,], x = coord_pop[i,1], y = coord_pop[i,2], labels = "",
radius = pop_size[i], col = rainbow(2))
}
runApp('app2.R')
radius_scaling_factor
lon_range
lat_range
plot_area
radius_scaling_factor
pop_size
runs <- fread(paste0("input_admx.2.Q"))
to_color <- fread("temporal/to_color.txt", header = FALSE)
colnames(to_color) <- c("POP1", "POP2")
coord <- fread(paste0("www/coord.txt"), header = TRUE)
# Combine population and ancestry data
admixture_data <- cbind(to_color, runs)
admixture_data <- merge(admixture_data, coord, by = c("POP1", "POP2"))
admixture_data <- admixture_data %>%
relocate(c(Pop_name, LAT, LON), .before = V1)
cordi <- select(admixture_data, c("POP1", "POP2", "LAT", "LON"))
Npop <- length(unique(admixture_data$POP2))
qpop <- matrix(NA, ncol = 2, nrow = Npop)
# Calculate mean ancestry proportions for each population
for (i in seq_len(Npop)) {
pop_subset <- admixture_data$POP2 == unique(admixture_data$POP2)[i]
qpop[i, ] <- apply(runs[pop_subset, ], 2, mean)
}
# Calculate mean coordinates for each population
coord_pop <- matrix(NA, ncol = 2, nrow = Npop) # Assuming LAT and LON as the two columns
for (i in seq_len(Npop)) {
pop_subset <- admixture_data$POP2 == unique(admixture_data$POP2)[i]
coord_pop[i, ] <- apply(cordi[pop_subset, c("LON", "LAT")], 2, mean)
}
library(mapplots)
library(maps)
# Increase plot window size
dev.new(width = 10, height = 10)  # Adjust window size as needed
# Adjust margins
par(mar = c(3, 3, 3, 3))  # Smaller margins
# Expand x and y limits by 20%
xlim <- c(
min(coord_pop[,1]) - 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1])),
max(coord_pop[,1]) + 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1]))
)
ylim <- c(
min(coord_pop[,2]) - 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2])),
max(coord_pop[,2]) + 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2]))
)
# Create base map with adjusted limits
basemap(xlim, ylim)
plot(coord_pop, xlab = "LON", ylab = "LAT", type = "n", xlim = xlim, ylim = ylim)
map(add = TRUE, col = "grey90", fill = TRUE)
# Example population sizes for dynamic pie chart radius
lon_range <- max(coord_pop[, 1]) - min(coord_pop[, 1])  # Longitude range
lat_range <- max(coord_pop[, 2]) - min(coord_pop[, 2])  # Latitude range
plot_area <- lon_range * lat_range
radius_scaling_factor <- sqrt(plot_area) / 60  # Adjust the divisor based on desired size
pop_size <- runif(Npop, min = 1, max = 5)  # Random example
for (i in 1:Npop) {
scaled_radius <- pop_size[i] * radius_scaling_factor
add.pie(z = qpop[i,], x = coord_pop[i, 1], y = coord_pop[i, 2], labels = "",
radius = scaled_radius, col = rainbow(2))
}
# Add pie charts to the map
for (i in 1:Npop) {
add.pie(z = qpop[i,], x = coord_pop[i,1], y = coord_pop[i,2], labels = "",
radius = pop_size[i], col = rainbow(2))
}
for (i in 1:Npop) {
add.pie(z = qpop[i,], x = coord_pop[i,1], y = coord_pop[i,2], labels = "",
radius = pop_size[i], col = rainbow(2))
}
for (i in 1:Npop) {
add.pie(z = qpop[i,], x = coord_pop[i,1], y = coord_pop[i,2], labels = "",
radius = pop_size[i], col = rainbow(2))
}
# Create base map with adjusted limits
basemap(xlim, ylim)
plot(coord_pop, xlab = "LON", ylab = "LAT", type = "n", xlim = xlim, ylim = ylim)
map(add = TRUE, col = "grey90", fill = TRUE)
# Example population sizes for dynamic pie chart radius
lon_range <- max(coord_pop[, 1]) - min(coord_pop[, 1])  # Longitude range
lat_range <- max(coord_pop[, 2]) - min(coord_pop[, 2])  # Latitude range
plot_area <- lon_range * lat_range
radius_scaling_factor <- sqrt(plot_area) / 60  # Adjust the divisor based on desired size
pop_size <- runif(Npop, min = 1, max = 5)  # Random example
for (i in 1:Npop) {
scaled_radius <- pop_size[i] * radius_scaling_factor
add.pie(z = qpop[i,], x = coord_pop[i, 1], y = coord_pop[i, 2], labels = "",
radius = scaled_radius, col = rainbow(2))
}
# Add pie charts to the map
for (i in 1:Npop) {
add.pie(z = qpop[i,], x = coord_pop[i,1], y = coord_pop[i,2], labels = "",
radius = pop_size[i], col = rainbow(2))
}
runApp('app2.R')
runs <- fread(paste0("input_admx.2.Q"))
to_color <- fread("temporal/to_color.txt", header = FALSE)
colnames(to_color) <- c("POP1", "POP2")
coord <- fread(paste0("www/coord.txt"), header = TRUE)
# Combine population and ancestry data
admixture_data <- cbind(to_color, runs)
admixture_data <- merge(admixture_data, coord, by = c("POP1", "POP2"))
admixture_data <- admixture_data %>%
relocate(c(Pop_name, LAT, LON), .before = V1)
cordi <- select(admixture_data, c("POP1", "POP2", "LAT", "LON"))
Npop <- length(unique(admixture_data$POP2))
qpop <- matrix(NA, ncol = 2, nrow = Npop)
# Calculate mean ancestry proportions for each population
for (i in seq_len(Npop)) {
pop_subset <- admixture_data$POP2 == unique(admixture_data$POP2)[i]
qpop[i, ] <- apply(runs[pop_subset, ], 2, mean)
}
# Calculate mean coordinates for each population
coord_pop <- matrix(NA, ncol = 2, nrow = Npop) # Assuming LAT and LON as the two columns
for (i in seq_len(Npop)) {
pop_subset <- admixture_data$POP2 == unique(admixture_data$POP2)[i]
coord_pop[i, ] <- apply(cordi[pop_subset, c("LON", "LAT")], 2, mean)
}
library(mapplots)
library(maps)
# Increase plot window size
dev.new(width = 10, height = 10)  # Adjust window size as needed
# Adjust margins
par(mar = c(3, 3, 3, 3))  # Smaller margins
# Expand x and y limits by 20%
xlim <- c(
min(coord_pop[,1]) - 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1])),
max(coord_pop[,1]) + 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1]))
)
ylim <- c(
min(coord_pop[,2]) - 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2])),
max(coord_pop[,2]) + 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2]))
)
# Create base map with adjusted limits
basemap(xlim, ylim)
plot(coord_pop, xlab = "LON", ylab = "LAT", type = "n", xlim = xlim, ylim = ylim)
map(add = TRUE, col = "grey90", fill = TRUE)
# Example population sizes for dynamic pie chart radius
lon_range <- max(coord_pop[, 1]) - min(coord_pop[, 1])  # Longitude range
lat_range <- max(coord_pop[, 2]) - min(coord_pop[, 2])  # Latitude range
plot_area <- lon_range * lat_range
radius_scaling_factor <- sqrt(plot_area) / 60  # Adjust the divisor based on desired size
pop_size <- runif(Npop, min = 1, max = 5)  # Random example
for (i in 1:Npop) {
scaled_radius <- pop_size[i] * radius_scaling_factor
add.pie(z = qpop[i,], x = coord_pop[i, 1], y = coord_pop[i, 2], labels = "",
radius = scaled_radius, col = rainbow(2))
}
# Add pie charts to the map
for (i in 1:Npop) {
add.pie(z = qpop[i,], x = coord_pop[i,1], y = coord_pop[i,2], labels = "",
radius = pop_size[i], col = rainbow(2))
}
library(mapplots)
library(maps)
# Increase plot window size
dev.new(width = 10, height = 10)  # Adjust window size as needed
# Adjust margins
par(mar = c(3, 3, 3, 3))  # Smaller margins
# Expand x and y limits by 20%
xlim <- c(
min(coord_pop[,1]) - 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1])),
max(coord_pop[,1]) + 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1]))
)
ylim <- c(
min(coord_pop[,2]) - 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2])),
max(coord_pop[,2]) + 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2]))
)
# Create base map with adjusted limits
basemap(xlim, ylim)
plot(coord_pop, xlab = "LON", ylab = "LAT", type = "n", xlim = xlim, ylim = ylim)
map(add = TRUE, col = "grey90", fill = TRUE)
# Example population sizes for dynamic pie chart radius
lon_range <- max(coord_pop[, 1]) - min(coord_pop[, 1])  # Longitude range
lat_range <- max(coord_pop[, 2]) - min(coord_pop[, 2])  # Latitude range
plot_area <- lon_range * lat_range
radius_scaling_factor <- sqrt(plot_area) / 60  # Adjust the divisor based on desired size
pop_size <- runif(Npop, min = 1, max = 5)  # Random example
for (i in 1:Npop) {
scaled_radius <- pop_size[i] * radius_scaling_factor
add.pie(z = qpop[i,], x = coord_pop[i, 1], y = coord_pop[i, 2], labels = "",
radius = scaled_radius, col = rainbow(2))
}
# Add pie charts to the map
for (i in 1:Npop) {
add.pie(z = qpop[i,], x = coord_pop[i,1], y = coord_pop[i,2], labels = "",
radius = pop_size[i], col = rainbow(2))
}
pop_size
pop_size
radius_scaling_factor
plot_area
lat_range
lon_range
coord_pop
sqrt(plot_area)
Npop
runif(Npop, min = 1, max = 5)
runif(Npop, min = 1, max = 10)
Npop
Npop
unique(admixture_data$POP2)
to_color
library(dplyr)
to_color %>%
count(POP2)
to_color2 <- to_color %>%
inner_join(pop_counts, by = "POP2")
pop_counts <-to_color %>%
count(POP2)
to_color2 <- to_color %>%
inner_join(pop_counts, by = "POP2")
to_color2
runs <- fread(paste0("input_admx.2.Q"))
to_color <- fread("temporal/to_color.txt", header = FALSE)
colnames(to_color) <- c("POP1", "POP2")
coord <- fread(paste0("www/coord.txt"), header = TRUE)
library(dplyr)
pop_counts <-to_color %>%
count(POP2)
to_color2 <- to_color %>%
inner_join(pop_counts, by = "POP2")
# Combine population and ancestry data
admixture_data <- cbind(to_color, runs)
admixture_data <- merge(admixture_data, coord, by = c("POP1", "POP2"))
admixture_data <- admixture_data %>%
relocate(c(Pop_name, LAT, LON), .before = V1)
cordi <- select(admixture_data, c("POP1", "POP2", "LAT", "LON"))
Npop <- length(unique(admixture_data$POP2))
qpop <- matrix(NA, ncol = 2, nrow = Npop)
# Calculate mean ancestry proportions for each population
for (i in seq_len(Npop)) {
pop_subset <- admixture_data$POP2 == unique(admixture_data$POP2)[i]
qpop[i, ] <- apply(runs[pop_subset, ], 2, mean)
}
# Calculate mean coordinates for each population
coord_pop <- matrix(NA, ncol = 2, nrow = Npop) # Assuming LAT and LON as the two columns
for (i in seq_len(Npop)) {
pop_subset <- admixture_data$POP2 == unique(admixture_data$POP2)[i]
coord_pop[i, ] <- apply(cordi[pop_subset, c("LON", "LAT")], 2, mean)
}
library(mapplots)
library(maps)
# Increase plot window size
dev.new(width = 10, height = 10)  # Adjust window size as needed
# Adjust margins
par(mar = c(3, 3, 3, 3))  # Smaller margins
# Expand x and y limits by 20%
xlim <- c(
min(coord_pop[,1]) - 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1])),
max(coord_pop[,1]) + 0.2 * (max(coord_pop[,1]) - min(coord_pop[,1]))
)
ylim <- c(
min(coord_pop[,2]) - 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2])),
max(coord_pop[,2]) + 0.2 * (max(coord_pop[,2]) - min(coord_pop[,2]))
)
# Create base map with adjusted limits
basemap(xlim, ylim)
plot(coord_pop, xlab = "LON", ylab = "LAT", type = "n", xlim = xlim, ylim = ylim)
map(add = TRUE, col = "grey90", fill = TRUE)
######
# Set a scaling factor for radius (adjust to fit your map)
radius_scaling_factor <- 0.1  # Adjust this value based on your map size
# Add pie charts, with radius scaled by population count
for (i in 1:Npop) {
# Get the population size from the merged data
pop_size <- to_color2$n[i]
# Scale the radius based on the population size
scaled_radius <- pop_size * radius_scaling_factor
# Add the pie chart at the corresponding coordinates
add.pie(z = qpop[i,],
x = coord_pop[i, 1],
y = coord_pop[i, 2],
labels = "",
radius = scaled_radius,
col = rainbow(2))
}
pop_counts
radius_scaling_factor <- 0.01  # Adjust this value based on your map size
# Add pie charts, with radius scaled by population count
for (i in 1:Npop) {
# Get the population size from the merged data
pop_size <- to_color2$n[i]
# Scale the radius based on the population size
scaled_radius <- pop_size * radius_scaling_factor
# Add the pie chart at the corresponding coordinates
add.pie(z = qpop[i,],
x = coord_pop[i, 1],
y = coord_pop[i, 2],
labels = "",
radius = scaled_radius,
col = rainbow(2))
}
######
# Set a scaling factor for radius (adjust to fit your map)
radius_scaling_factor <- 0.01  # Adjust this value based on your map size
# Add pie charts, with radius scaled by population count
for (i in 1:Npop) {
# Get the population size from the merged data
pop_size <- to_color2$n[i]
# Scale the radius based on the population size
scaled_radius <- pop_size * radius_scaling_factor
# Add the pie chart at the corresponding coordinates
add.pie(z = qpop[i,],
x = coord_pop[i, 1],
y = coord_pop[i, 2],
labels = "",
radius = scaled_radius,
col = rainbow(2))
}
# Create base map with adjusted limits
basemap(xlim, ylim)
plot(coord_pop, xlab = "LON", ylab = "LAT", type = "n", xlim = xlim, ylim = ylim)
map(add = TRUE, col = "grey90", fill = TRUE)
######
# Set a scaling factor for radius (adjust to fit your map)
radius_scaling_factor <- 0.01  # Adjust this value based on your map size
# Add pie charts, with radius scaled by population count
for (i in 1:Npop) {
# Get the population size from the merged data
pop_size <- to_color2$n[i]
# Scale the radius based on the population size
scaled_radius <- pop_size * radius_scaling_factor
# Add the pie chart at the corresponding coordinates
add.pie(z = qpop[i,],
x = coord_pop[i, 1],
y = coord_pop[i, 2],
labels = "",
radius = scaled_radius,
col = rainbow(2))
}
basemap(xlim, ylim)
plot(coord_pop, xlab = "LON", ylab = "LAT", type = "n", xlim = xlim, ylim = ylim)
map(add = TRUE, col = "grey90", fill = TRUE)
######
# Set a scaling factor for radius (adjust to fit your map)
radius_scaling_factor <- 0.001  # Adjust this value based on your map size
# Add pie charts, with radius scaled by population count
for (i in 1:Npop) {
# Get the population size from the merged data
pop_size <- to_color2$n[i]
# Scale the radius based on the population size
scaled_radius <- pop_size * radius_scaling_factor
# Add the pie chart at the corresponding coordinates
add.pie(z = qpop[i,],
x = coord_pop[i, 1],
y = coord_pop[i, 2],
labels = "",
radius = scaled_radius,
col = rainbow(2))
}
# Create base map with adjusted limits
basemap(xlim, ylim)
plot(coord_pop, xlab = "LON", ylab = "LAT", type = "n", xlim = xlim, ylim = ylim)
map(add = TRUE, col = "grey90", fill = TRUE)
######
# Set a scaling factor for radius (adjust to fit your map)
radius_scaling_factor <- 0.05  # Adjust this value based on your map size
# Add pie charts, with radius scaled by population count
for (i in 1:Npop) {
# Get the population size from the merged data
pop_size <- to_color2$n[i]
# Scale the radius based on the population size
scaled_radius <- pop_size * radius_scaling_factor
# Add the pie chart at the corresponding coordinates
add.pie(z = qpop[i,],
x = coord_pop[i, 1],
y = coord_pop[i, 2],
labels = "",
radius = scaled_radius,
col = rainbow(2))
}
basemap(xlim, ylim)
plot(coord_pop, xlab = "LON", ylab = "LAT", type = "n", xlim = xlim, ylim = ylim)
map(add = TRUE, col = "grey90", fill = TRUE)
######
# Set a scaling factor for radius (adjust to fit your map)
radius_scaling_factor <- 0.005  # Adjust this value based on your map size
# Add pie charts, with radius scaled by population count
for (i in 1:Npop) {
# Get the population size from the merged data
pop_size <- to_color2$n[i]
# Scale the radius based on the population size
scaled_radius <- pop_size * radius_scaling_factor
# Add the pie chart at the corresponding coordinates
add.pie(z = qpop[i,],
x = coord_pop[i, 1],
y = coord_pop[i, 2],
labels = "",
radius = scaled_radius,
col = rainbow(2))
}
scaled_radius
pop_size
pop_size
to_color2
pop_counts
runApp('app2.R')
